import { Tokenizer } from '../../tokenizer/index.js';

class ESTokenizer extends Tokenizer {
  constructor() {
    super([
     	{ matcher: /[ \t]+/, type: 'operator' },
     	{ matcher: /\r?\n/, type: 'operator' },
     	{ matcher: /\/\/(.*?)(?=\r?\n|$)/, 
      	 type: 'comment', 
        extractor: v => v.slice(2) 
      },
     	{ matcher: /'[^'\r\n]+'/, 
      	 type: 'string-literal',
        extractor: v => v.slice(0, -1) // <-- previous 1
      },
     	{ matcher: /'[^'\r\n]+'/, 
      	 type: 'string-literal', 
        extractor: v => v.slice(0, -1) // <-- previous 1
      },
     	{ matcher: /`[^`]+`/, 
      	 type: 'string-literal', 
        extractor: v => v.slice(0, -1) // <-- previous 1
      },
     	{ matcher: /-?[0-9]+\.?[0-9]*(?![a-zA-Z$_])/, 
      	 type: 'number-literal', 
        extractor: v => parseFloat(v) 
      },
     	{ matcher: /{/, type: 'operator' },
     	{ matcher: /}/, type: 'operator' },
     	{ matcher: /\[/, type: 'operator' },
     	{ matcher: /\]/, type: 'operator' },
     	{ matcher: /\(/, type: 'operator' },
     	{ matcher: /\)/, type: 'operator' },
     	{ matcher: /;/, type: 'operator' },
     	{ matcher: /:/, type: 'operator' },
     	{ matcher: /,/, type: 'operator' },
     	{ matcher: /\.\.\./, type: 'operator' },
     	{ matcher: /\./, type: 'operator' },
     	{ matcher: /\*\*/, type: 'operator' },
     	{ matcher: /\*/, type: 'operator' },
     	{ matcher: /!==/, type: 'operator-comparison' },
     	{ matcher: /===/, type: 'operator-comparison' },  
     	{ matcher: /==/, type: 'operator-comparison' },  
     	{ matcher: /=>/, type: 'operator-comparison' },
     	{ matcher: /=/, type: 'operator-comparison' },
     	{ matcher: /!=/, type: 'operator-comparison' },
     	{ matcher: /&&/, type: 'operator-logical' },
     	{ matcher: /&/, type: 'operator-logical' },
     	{ matcher: /\^/, type: 'operator-logical' },
     	{ matcher: /~/, type: 'operator' },
     	{ matcher: /!/, type: 'operator' },
     	{ matcher: /\|\|/, type: 'operator-logical' },
     	{ matcher: /\|/, type: 'operator' },
     	{ matcher: /\+\+/, type: 'operator-maths' },
     	{ matcher: /\+/, type: 'operator-maths' },
     	{ matcher: /\-\-/, type: 'operator-maths' },
     	{ matcher: /\-/, type: 'operator-maths' },
     	{ matcher: /\\/, type: 'operator-maths' },
     	{ matcher: /%/, type: 'operator-maths' },
     	{ matcher: /\?\?/, type: 'operator' },
     	{ matcher: /\?/, type: 'operator' },
     	{ matcher: />=/, type: 'operator-comparison' },
     	{ matcher: /<=/, type: 'operator-comparison' },
     	{ matcher: />>/, type: 'operator' },
     	{ matcher: />/, type: 'operator' },
     	{ matcher: /<</, type: 'operator' },
     	{ matcher: /</, type: 'operator' },
     	{ matcher: /null/, type: 'value' },
     	{ matcher: /true/, type: 'value', 
        extractor: v => v },
     	{ matcher: /false/, type: 'value', 
        extractor: v => v },
     	{ matcher: /import/, type: 'declaration' },
     	{ matcher: /export/, type: 'declaration' },
     	{ matcher: /from/, type: 'statement' },
     	{ matcher: /as/, type: 'statement' },
     	{ matcher: /for/, type: 'statement' },
     	{ matcher: /while/, type: 'statement' },
     	{ matcher: /in/, type: 'statement' },
     	{ matcher: /of/, type: 'statement' },
     	{ matcher: /break/, type: 'statement' },
     	{ matcher: /continue/, type: 'statement' },
     	{ matcher: /do/, type: 'statement' },
     	{ matcher: /if/, type: 'statement' },
     	{ matcher: /else/, type: 'statement' },
     	{ matcher: /switch/, type: 'statement' },
     	{ matcher: /case/, type: 'statement' },
     	{ matcher: /default/, type: 'statement' },
     	{ matcher: /function/, type: 'declaration' },
     	{ matcher: /return/, type: 'statement' },
     	{ matcher: /yield/, type: 'operator' },
     	{ matcher: /await/, type: 'operator' },
     	{ matcher: /try/, type: 'statement' },
     	{ matcher: /catch/, type: 'statement' },
     	{ matcher: /finally/, type: 'statement' },
     	{ matcher: /throw/, type: 'statement' },
     	{ matcher: /typeof/, type: 'operator' },
     	{ matcher: /new/, type: 'operator' },
     	{ matcher: /class/, type: 'declaration' },
     	{ matcher: /super/, type: 'declaration' },
     	{ matcher: /let/, type: 'declaration' },
     	{ matcher: /const/, type: 'declaration' },
     	{ matcher: /this/, type: 'declaration' },
     	{ matcher: /[a-zA-Z$_][a-zA-Z0-9$_]*/, 
       	type: 'identifier', extractor: v => v }
    ])
  }
}

export { ESTokenizer as Tokenizer }
